1. 垂直居中的方法
    1. 行内元素
    ```
    <!--方法1-->
    文字、链接等行内元素包裹在display:block的块级元素中，设置外面的元素text-align:center即可实现居中
    ```
    2. 块级元素(固定宽高/非固定宽高)
        ```
        <!--方法1-->
        一个元素的水平居中: 一个块级元素，可以直接设置{margin: 0 auto}
        
        <!--方法2-->
        多个块级元素的水平居中: 将外部包裹的元素设置为{display: block}，内部的div全部设置为内联块{display: inling-block},然后设置{text-align:center}
        
        <!--方法3-->
        单行内元素的垂直居中: 设置line-height的高度和外面盒子的高度一致
        
        <!--方法4-->
        多行元素的垂直居中: 让包裹快模拟表格单元，然后用vertical-align来进行设置 {display: table-cell;
          vertical-align: middle;}
          
        <!--方法5-->
        已知宽高设置元素的水平垂直居中: 设置position: absolute; top: 50%; left: 50%; margin-top: -(盒子的高度); margin-left: -(盒子的宽度)
        
        <!--方法6-->
        已知宽高设置元素的水平垂直居中(CSS3): 设置父元素{display: flex;}, 设置子元素{margin: auto}
        
        <!--方法7-->
        未知宽高实现水平垂直居中(CSS3): 设置元素的{position: absolute; left: 50%; top: 50%; transform: translate(-50% -50%);}
        
        <!--方法8-->
        已知宽高，设置水平垂直居中(flex布局): 设置父元素{justify-content: center; align-items: center}
        
        <!--方法9-->
        图片的水平垂直居中: 设置祖父元素为{display: table},设置父元素{display: table-cell; vertical-align: center; text-align: center}
        ```
2. flex+rem布局，垂直居中(align-items: center)和水平居中(justify-content: center)分别用flex种的哪两个元素设置的？
    1. 你flex布局做过什么?
        1. 父级元素设置{display: flex; display:-webkit-box; display:-mox-box; display:-mz-flexbox}
        2. 容器的属性   
            2. flex-direction:row | row-reverse | column | column-reverse (决定主轴的方向)
            3. flex-wrap: wrap | nowrap | wrap-reverse (如果一条轴线排不下，是否换行)
            4. flex-flow: (flex-direction和flex-wrap的简写)
            5. justify-content:  flex-start | flex-end | center | space-between | space-around (定义项目在主轴上面的对齐方式)
            6. align-items: flex-start | flex-end | center | baseline | stretch
            7. align-content: flex-start | flex-end | center | space-between | space-around  (多根轴线的对齐方式)
        3. 项目的属性
            1. order: (数值越小越靠前)
            2. flex-grow: (定义项目的放大比例)
            3. flex-shink: (定义项目的缩小比例)
            4. flex-basis: (计算主轴是否有多余的空间)
            5. flex: flex-grow flex-shink flex-basis (默认 0 1 auto)。flex 的值可以是无单位数字（如：1, 2, 3），也可以是有单位数字（如：15px，30px，60px），还可以是 none 关键字。子容器会按照 flex 定义的尺寸比例自动伸缩，如果取值为none 则不伸缩。
            6. align-self: (允许单个项目和其他项目有不同的对齐方式)
3. vue的模板和方法
    1. active-class是哪个组件的属性？嵌套路由怎么定义？
        1. vue-router模块的router-link组件。
    2. 怎么定义vue-router的动态路由？怎么获取传过来的动态参数？
        1. 在router目录下的index.js文件中，对path属性加上/:id。  使用router对象的params.id
    3. vue-router有哪几种导航钩子？
        1. 三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件
    4. scss是什么？安装使用的步骤是？有哪几大特性？
        1. 预处理css，把css当前函数编写，定义变量,嵌套。 先装css-loader、node-loader、sass-loader等加载器模块，在webpack-base.config.js配置文件中加多一个拓展:extenstion，再加多一个模块：module里面test、loader
    5. scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？
        1. 使用步骤：
        2. 第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）。
        3. 第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss。
        4. 第三步：还是在同一个文件，配置一个module属性。
        5. 第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”。
        6. 有哪几大特性:
            1、可以用变量，例如（$变量名称=值）；
            2、可以用混合器，例如（）；
            3、可以嵌套 ；
    6. mint-ui是什么？怎么使用？说出至少三个组件使用方法？
        1. 基于vue的前端组件库。npm安装，然后import样式和js，vue.use（mintUi）全局引入。在单个组件局部引入：import {Toast} from ‘mint-ui’。组件一：Toast(‘登录成功’)；组件二：mint-header；组件三：mint-swiper
    7. v-model是什么？怎么使用？ vue中标签怎么绑定事件？
        1. 可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue的model层的data属性。绑定事件：<input @click=doLog() />
    8. axios是什么？怎么使用？描述使用它实现登录功能的流程？
        1. 请求后台资源的模块。npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中。
    9. axios+tp5进阶中，调用axios.post(‘api/user’)是进行的什么操作？axios.put(‘api/user/8′)呢？
        1. 跨域，添加用户操作，更新操作。
    10. 什么是RESTful API？怎么使用?
        1. 是一个api的标准，无状态请求。请求的路由地址是固定的，如果是tp5则先路由配置中把资源路由配置好。标准有：.post .put .delete
    11. vuex是什么？怎么使用？哪种功能场景使用它？
        1. vue框架中状态管理。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车
    12. mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？
        1. 一个model+view+viewModel框架，数据模型model，viewModel连接两个
        2. vue数据驱动，通过数据来显示视图层而不是节点操作。
        3. 数据操作比较多的场景，更加便捷
    13. 自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？
        1. 全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives，钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）钩子函数参数：el、binding
    14. 说出至少4种vue当中的指令和它的用法？
        1. v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定
    15. vue-router是什么？它有哪些组件？
        1. vue用来写路由一个插件。router-link、router-view
    16. 导航钩子有哪些？它们有哪些参数？
        1. 导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave, 参数：有to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种
    17. Vue的双向数据绑定原理是什么？
        1. vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
        2. 具体步骤：
            1. 第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter，这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化
            2. 第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
            3. 第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，
            4. 第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁。到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。
    18. 请详细说下你对vue生命周期的理解？
        1. 总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。
        2. 创建前/后： 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。
        3. 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。
        4. 更新前/后：当data变化时，会触发beforeUpdate和updated方法。
        5. 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在
    19. 请说下封装 vue 组件的过程？
        1. 首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题
        2. 然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。
    20. 你是怎么认识vuex的？
        1. vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。
        2. 通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。
        3. 应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。
    21. vue-loader是什么？使用它的用途有哪些？
        1. 解析.vue文件的一个加载器，跟template/js/style转换成js模块。
        2. 用途：js可以写es6、style样式可以scss或less、template可以加jade等
    22. 请说出vue.cli项目中src目录每个文件夹和文件的用法？
        1. assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件
    23. 聊聊你对Vue.js的template编译的理解？
        1. 就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）
        2. 首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。
        3. 然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）
4. 作用域，作用域链
    1. JS的作用域指的是变量的作用范围，内部作用域由函数的形参、实参、局部变量、函数构成。
    2. 内部作用域和外部作用域一层层的链接起来形成作用域链，当在函数内部访问一个变量的时候，首先查找自己的内部作用域有没有这个变量，如果没有的话就到这个对象的原型对象中去查找，还是没有的话就到该作用域所在的作用域查找，直到到window所在的作用域，每个函数在声明的时候，都会默认有一个外部作用域存在。
5. 原型，原型链
    1. 原型
        1. js中的所有对象都包含了一个_proto_属性，这个属性对应的就是该对象的原型。
        2. js函数对象，除了原型_proto_之外，还预置了一个prototype属性。
        3. 当函数对象作为构造函数创建实例的时候，该prototype属性值将被作为实例的原型_proto_。
    2. 原型链
        1. 当一个对象调用的属性/方法自身不存在时候，就回去自身_proto_关联的前辈prototype对象上面去找
        2. 如果没有找到，就会去该prototype原型_proto_关联的前辈prototype查找。以此类推，直到找到属性/方法或者undefined为止。从而形成所谓的“原型链”。
    3. 原型特点:
        1. js对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变。
6. 闭包，为什么要用闭包？
    1. 闭包指的是有权访问另一个函数作用域中变量的函数，创建闭包的最常见方法就是在一个函数的内部创建另外一个函数，通过一个函数访问这个函数的局部变量，利用闭包可以突破作用域链。
    2. 闭包的特性
        1. 函数内在嵌套函数
        2. 内部函数可以引用外层的参数和变量
        3. 参数和变量不会被垃圾回收机制回收
7. ajax和fetch的区别？
    1. ajax的本质是使用XMLHttpRequest对象来请求数据
    ```
    function ajax (url, fnSunc, fnFaild) {
        <!--1.创建ajax对象-->
        if (window.XMLHttpRequest) {
            var xhr = new XMLHttpRequest();
        } else {
            var xhr = new ActiveXObject("Microsoft.XMLHTTP");
        }
        
        <!--2.连接服务器-->
        xhr.open("GET", url, true);
        
        <!--3.发送-->
        xhr.send();
        
        <!--4.接收数据-->
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4) {
                if (xhr.status == 200) {
                    alert("成功" + xhr.responseText);
                    fnSunc(xhr.responseText);
                } else {
                    alert(失败了);
                    fnFaild();
                }
            }
        }
    }
    ```
    2. fetch是全部变量window的一个方法，他的主要特点是:
        1. 第一个参数是url
        2. 第二个可选参数，可以控制不同配置的init对象
        3. 使用了js Promises来处理结果/回调
        ```
        fetch("/some/url").then(function (responese) {
            return  // 执行成功，第一步
        }).then(function (returnedValue) {
            //  执行成功，第二部
        }).catch (function (err) {
            // 中途有任何错误，在此处理
        }) 
        ```
    3. fetch规范和jQuery.ajax()主要有两种方式不同
        1. 从fetch()返回的Promise将不会拒绝HTTP错误状态，即时响应是一个HTTP 404或500.相反，他会正常解决(其中ok状态设置为false)，并且仅仅在网络故障时或任何阻止请求完成时，他才会拒绝。
        ```
        <!--做简单的封装-->
        function checkStatus(response) {
            if (response.status >= 200 && response.status < 300) {
                return response
            } else {
                var error = new Error(response.statusText)
                error.response = response
                throw error
            }
        }
        
        function parseJSON (response) {
            return response.json()
        }
        
        fetch('/uses')
            .then(checkStatus)
            .then(parseJSON)
            .then(function (data) {
                console.log('request succeeded with JSON response', data)
            })
            .catch(function (error) {
                console.log('request failed', error)
            })
        ```
        2. 默认情况下，fetch在服务端不会发送或接收任何cookies，如果站点依赖于维护一个用户会话，则导致未经认证的请求(要发送cookies，必须发送凭据投)。这一点也可以做一些处理，如果想要在同域中自动发送cookie，加上credentials的same-origin选项
        ```
        fetch(url, {
            credentials: "same-origin"
        })
        ```
        3. same-origin值使得fetch处理Cookie与XMLHttpRequest类似。 否则，Cookie将不会被发送，导致这些请求不保留认证会话。
           对于CORS请求，使用include值允许将凭据发送到其他域：
         ```
         fetch(url, {
             credentials: "include"
         })
         ```
    4. fetch采用了Promise的异步处理机制，使用起来比ajax简单。
8. webpack配置
9. node接口
10. 优化
11. 链式调用的原理
12. koa框架
13. 版本管理
14. 对数组的操作
15. ul和ol的区别
16. call和apply的区别
17. JS由以下三个部分组成:
    1. ECMAScript（核心）:JavaScript语言基础
    2. DOM(文档对象模型)：规定了访问html和xml的接口
    3. BOM(浏览器对象模型)：提过了浏览器窗口之间进行交互的对象和方法
18. JS的数据类型
    1. 基本数据类型: String、Number、Boolean、Undefined、Null、symbol
    2. 引用数据类型: Function、Object、Array、Date、RegExp
19. 检测浏览器版本有哪些方式
    1. 根据navigator.userAgent // "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1"
    2. 根据window的对象成员
20. JS有哪些内置对象？
    1. 数据封装类对象：Object/Array/Boolean/Number/String
    2. 其他对象：Function/Arguments/Math/Date/RegExp/Error
    3. ES6新增对象: Symbol/Map/Set/Promises/Proxy/Reflect
21. 谈谈JS的基本规范？
    1. 代码缩进，建议使用"四个空格"缩进；
    2. 代码段使用{}包裹；
    3. 语句结束使用;
    4. 变量和函数在使用前进行声明
    5. 以大写字母开头命名构造函数，全大写命名常量
    6. 规范定义JSON对象，补全双引号
    7. 用{}和[]声明对象和数组
22. 如何编写高性能的javascript？
    1. 遵循严格模式‘use strict’
    2. 将js脚本放在页面底部，加快渲染页面
    3. 将js脚本成组打包，减少请求
    4. 使用非阻塞方式下载js脚本
    5. 尽量使用局部变量来保存全局变量
    6. 尽量减少使用闭包
    7. 使用window对象属性方法时，省略window
    8. 尽量减少对象成员嵌套
    9. 缓存DOM节点的访问
    10. 通过避免使用eval()和Function()构造器
    11. 给setTimeout()和setInterval()传递函数而不是字符串作为参数
    12. 尽量使用直接量创建对象和数组
    13. 最小化重绘(repaint)和回流(reflow)
23. 根据浏览器的渲染过程，DOM树和渲染树的区别？
    1. 浏览器的渲染过程:
        1. 解析HTML构建DOM，并行请求css/image/js
        2. css文件下载完成，开始构建CSSOM(CSS树)
        3. CSSOM构建结束后，和DOM一起生产Render Tree(渲染树)
        4. 布局(Layout)： 计算每个节点在屏幕的位置
        5. 显示(Painting): 通过显卡把页面画到屏幕上
    2. DOM树和渲染树的区别：
        1. DOM树和HTML标签一一对应，包括head和隐藏元素
        2. 渲染树不包含head和隐藏元素，大段文本中的每一行都是一个独立节点，每一个节点都有对应的css属性
24. 重绘和回流的区别和联系？
    1. 重绘: 当渲染树中的元素外观(如：颜色)发生改变，不影响布局时，产生重绘
    2. 回流: 当渲染树中的元素的布局(如：尺寸、位置、隐藏、状态)发生改变的时候，产生重绘回流
    3. 注意: js获取Layout属性值(如：offsetLeft、scrollTop、getComputedStyle等)也会引起回流。因为浏览器需要通过回流重新计算值
    4. 回流必将引起重绘，而重绘不一定会引起回流。
25. 如何最小化重绘和回流？
    1. 需要对元素进行复杂的操作时，可以先隐藏(display: none;),操作完成后在显示
    2. 需要创建多个DOM节点时，使用DocumentFragment创建后一次性的加入document
    3. 缓存Layout的属性值。如：var left = elem.offsetLeft，这样，多次使用left只产生一次回流
    4. 尽量避免用table布局
    5. 避免使用css表达式，因为每次调用都会重新计算值
    6. 批量修改元素样式
26. script是否会影响首屏显示的时间？
    1. 在解析HTML生产DOM过程中，js文件的下载是并行的，不需要DOM处理到script节点。因此script的位置不会影响首屏的开始时间
    2. 浏览器解析HTML是自上而下的线性过程，script作为HTML的一部分同样遵循这个原则
    3. 因此，script会延迟DomContentLoad，只显示上部分首屏内容，从而影响首屏显示的完成时间
27. js中的作用域和变量声名提升？
    1. js作用域：
        1. 在java、c语言中，作用域为for语句，if语句或者{}内的一块区域，称为作用域
        2. 在js中，作用域为function(){}内的区域，称为函数作用域
    2. js变量声明提升：
        1. 在js中，函数声明和变量声明经常被js引擎隐式的提升到当前作用域的顶部
        2. 声明语句中的赋值部分并不会被提升，只有名称被提升；
        3. 函数声明的优先级高于变量，如果变量名和函数名相同，且没有赋值，则函数声明会覆盖变量声明
        4. 如果函数有多个同名参数，那么最后一个参数会覆盖前面的同名参数。
28. javascript有几种类型的值？能画出啦内存图？
    1. 原始数据类型： Undefined、Null、String、Boolean、Number --- 栈
    2. 引用数据类型： 对象，数组，函数 --- 堆
    3. 两种类型的区别: 存储位置不同
    4. 原始数据类型是直接存放在栈中的简单数据段，占据空间小，大小固定，属于被频繁使用的数据；
    5. 引用数据类型存放在堆中的对象，占用空间大，大小不固定，如果存储在栈中，将会影响程序运行的性能
    6. 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址
    7. 当解析器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。
29. js如何实现一个类，怎么实例化这个类？
    1. 构造函数法(this+prototype) --- 用new关键字生成实例对象
        1. 缺点: 用到了this和prototype，编写复杂，可读性比较差
        ```
        function Mobile(name, price) {
            this.name = name;
            this.price = price;
        }
        Mobile.prototype.sell = function () {
            alert(this.name + ",售价$" + this.price)
        }
        var iphone7P = new Mobile("iphone7p", 6488);
        iphone7p.sell();
        ```
    2. Object.create法 --- 用Object.create()生成实例对象
        1. 缺点: 不能实现私有属性和私有方法，实例对象之间也不能共享数据
        ```
        var Person = {
            firstName: "Hong",
            lastNmae: "JingPing",
            age: 22,
            introduce: function () {
                alert(‘I am’ + Person.firstName + " " + Person.lastNmae)
            }
        }
        var person = Object.create(Person);
        person.introduce();
        
        <!--Object.create要求IE9+ 低版本浏览器可自动进行部署-->
        if (!Object.create) {
            Object.create = function (o) {
                function F() {}
                F.prototype = o;
                return new F();
            }
        }
        ```
    3. 极简主义法(消除this和prototype) --- 调用createNew()得到实例对象
        1. 优点：容易理解，结构清晰优雅，符合传统的"面向对象编程"的构造
        ```
        var Cat = {
            age: 6, // 共享数据 --- 定义在类对像内，createNew外
            createNew: function () {
                var cat = {};
                // var cat = Animal.createNew(); // 继承Animal类
                cat.name = "amy";
                var sound = "mie mie mie"; // 私有属性---定义在 createNew()内，输出对象外
                cat.makeSound = function () {
                    alert(sound); // 暴露私有属性
                };
                cat.changeAge = function (num) {
                    Cat.age = num; // 修改共享数据
                };
                return cat; // 输出对象
            }
        };
        
        var cat = Cat.createNew();
        cat.makeSound();
        ```
    4. ES6语法糖Class --- 用new关键字生成实例对象
    ```
    class Point() {
        constructor (x,y) {
            this.x = x;
            this.y = y;
        }
        toString() {
            return '(' + thsi.x + ',' + thsi.y + ')';
        }
    }
    var point = new Point(2, 3);
    ```