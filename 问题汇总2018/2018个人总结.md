1. 垂直居中的方法
    1. 行内元素
    ```
    <!--方法1-->
    文字、链接等行内元素包裹在display:block的块级元素中，设置外面的元素text-align:center即可实现居中
    ```
    2. 块级元素(固定宽高/非固定宽高)
        ```
        <!--方法1-->
        一个元素的水平居中: 一个块级元素，可以直接设置{margin: 0 auto}
        
        <!--方法2-->
        多个块级元素的水平居中: 将外部包裹的元素设置为{display: block}，内部的div全部设置为内联块{display: inling-block},然后设置{text-align:center}
        
        <!--方法3-->
        单行内元素的垂直居中: 设置line-height的高度和外面盒子的高度一致
        
        <!--方法4-->
        多行元素的垂直居中: 让包裹快模拟表格单元，然后用vertical-align来进行设置 {display: table-cell;
          vertical-align: middle;}
          
        <!--方法5-->
        已知宽高设置元素的水平垂直居中: 设置position: absolute; top: 50%; left: 50%; margin-top: -(盒子的高度); margin-left: -(盒子的宽度)
        
        <!--方法6-->
        已知宽高设置元素的水平垂直居中(CSS3): 设置父元素{display: flex;}, 设置子元素{margin: auto}
        
        <!--方法7-->
        未知宽高实现水平垂直居中(CSS3): 设置元素的{position: absolute; left: 50%; top: 50%; transform: translate(-50% -50%);}
        
        <!--方法8-->
        已知宽高，设置水平垂直居中(flex布局): 设置父元素{justify-content: center; align-items: center}
        
        <!--方法9-->
        图片的水平垂直居中: 设置祖父元素为{display: table},设置父元素{display: table-cell; vertical-align: center; text-align: center}
        ```
2. flex+rem布局，垂直居中(align-items: center)和水平居中(justify-content: center)分别用flex种的哪两个元素设置的？
    1. 你flex布局做过什么?
        1. 父级元素设置{display: flex; display:-webkit-box; display:-mox-box; display:-mz-flexbox}
        2. 容器的属性   
            2. flex-direction:row | row-reverse | column | column-reverse (决定主轴的方向)
            3. flex-wrap: wrap | nowrap | wrap-reverse (如果一条轴线排不下，是否换行)
            4. flex-flow: (flex-direction和flex-wrap的简写)
            5. justify-content:  flex-start | flex-end | center | space-between | space-around (定义项目在主轴上面的对齐方式)
            6. align-items: flex-start | flex-end | center | baseline | stretch
            7. align-content: flex-start | flex-end | center | space-between | space-around  (多根轴线的对齐方式)
        3. 项目的属性
            1. order: (数值越小越靠前)
            2. flex-grow: (定义项目的放大比例)
            3. flex-shink: (定义项目的缩小比例)
            4. flex-basis: (计算主轴是否有多余的空间)
            5. flex: flex-grow flex-shink flex-basis (默认 0 1 auto)。flex 的值可以是无单位数字（如：1, 2, 3），也可以是有单位数字（如：15px，30px，60px），还可以是 none 关键字。子容器会按照 flex 定义的尺寸比例自动伸缩，如果取值为none 则不伸缩。
            6. align-self: (允许单个项目和其他项目有不同的对齐方式)
3. vue的模板和方法
    1. active-class是哪个组件的属性？嵌套路由怎么定义？
        1. vue-router模块的router-link组件。
    2. 怎么定义vue-router的动态路由？怎么获取传过来的动态参数？
        1. 在router目录下的index.js文件中，对path属性加上/:id。  使用router对象的params.id
    3. vue-router有哪几种导航钩子？
        1. 三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件
    4. scss是什么？安装使用的步骤是？有哪几大特性？
        1. 预处理css，把css当前函数编写，定义变量,嵌套。 先装css-loader、node-loader、sass-loader等加载器模块，在webpack-base.config.js配置文件中加多一个拓展:extenstion，再加多一个模块：module里面test、loader
    5. scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？
        1. 使用步骤：
        2. 第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）。
        3. 第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss。
        4. 第三步：还是在同一个文件，配置一个module属性。
        5. 第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”。
        6. 有哪几大特性:
            1、可以用变量，例如（$变量名称=值）；
            2、可以用混合器，例如（）；
            3、可以嵌套 ；
    6. mint-ui是什么？怎么使用？说出至少三个组件使用方法？
        1. 基于vue的前端组件库。npm安装，然后import样式和js，vue.use（mintUi）全局引入。在单个组件局部引入：import {Toast} from ‘mint-ui’。组件一：Toast(‘登录成功’)；组件二：mint-header；组件三：mint-swiper
    7. v-model是什么？怎么使用？ vue中标签怎么绑定事件？
        1. 可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue的model层的data属性。绑定事件：<input @click=doLog() />
    8. axios是什么？怎么使用？描述使用它实现登录功能的流程？
        1. 请求后台资源的模块。npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中。
    9. axios+tp5进阶中，调用axios.post(‘api/user’)是进行的什么操作？axios.put(‘api/user/8′)呢？
        1. 跨域，添加用户操作，更新操作。
    10. 什么是RESTful API？怎么使用?
        1. 是一个api的标准，无状态请求。请求的路由地址是固定的，如果是tp5则先路由配置中把资源路由配置好。标准有：.post .put .delete
    11. vuex是什么？怎么使用？哪种功能场景使用它？
        1. vue框架中状态管理。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车
    12. mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？
        1. 一个model+view+viewModel框架，数据模型model，viewModel连接两个
        2. vue数据驱动，通过数据来显示视图层而不是节点操作。
        3. 数据操作比较多的场景，更加便捷
    13. 自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？
        1. 全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives，钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）钩子函数参数：el、binding
    14. 说出至少4种vue当中的指令和它的用法？
        1. v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定
    15. vue-router是什么？它有哪些组件？
        1. vue用来写路由一个插件。router-link、router-view
    16. 导航钩子有哪些？它们有哪些参数？
        1. 导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave, 参数：有to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种
    17. Vue的双向数据绑定原理是什么？
        1. vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
        2. 具体步骤：
            1. 第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter，这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化
            2. 第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
            3. 第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，
            4. 第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁。到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。
    18. 请详细说下你对vue生命周期的理解？
        1. 总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。
        2. 创建前/后： 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。
        3. 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。
        4. 更新前/后：当data变化时，会触发beforeUpdate和updated方法。
        5. 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在
    19. 请说下封装 vue 组件的过程？
        1. 首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题
        2. 然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。
    20. 你是怎么认识vuex的？
        1. vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。
        2. 通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。
        3. 应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。
    21. vue-loader是什么？使用它的用途有哪些？
        1. 解析.vue文件的一个加载器，跟template/js/style转换成js模块。
        2. 用途：js可以写es6、style样式可以scss或less、template可以加jade等
    22. 请说出vue.cli项目中src目录每个文件夹和文件的用法？
        1. assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件
    23. 聊聊你对Vue.js的template编译的理解？
        1. 就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）
        2. 首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。
        3. 然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）
4. 作用域，作用域链
    1. JS的作用域指的是变量的作用范围，内部作用域由函数的形参、实参、局部变量、函数构成。
    2. 内部作用域和外部作用域一层层的链接起来形成作用域链，当在函数内部访问一个变量的时候，首先查找自己的内部作用域有没有这个变量，如果没有的话就到这个对象的原型对象中去查找，还是没有的话就到该作用域所在的作用域查找，直到到window所在的作用域，每个函数在声明的时候，都会默认有一个外部作用域存在。
5. 原型，原型链
    1. 原型
        1. js中的所有对象都包含了一个_proto_属性，这个属性对应的就是该对象的原型。
        2. js函数对象，除了原型_proto_之外，还预置了一个prototype属性。
        3. 当函数对象作为构造函数创建实例的时候，该prototype属性值将被作为实例的原型_proto_。
    2. 原型链
        1. 当一个对象调用的属性/方法自身不存在时候，就回去自身_proto_关联的前辈prototype对象上面去找
        2. 如果没有找到，就会去该prototype原型_proto_关联的前辈prototype查找。以此类推，直到找到属性/方法或者undefined为止。从而形成所谓的“原型链”。
    3. 原型特点:
        1. js对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变。
6. 闭包，为什么要用闭包？
    1. 闭包指的是有权访问另一个函数作用域中变量的函数，创建闭包的最常见方法就是在一个函数的内部创建另外一个函数，通过一个函数访问这个函数的局部变量，利用闭包可以突破作用域链。
    2. 闭包的特性
        1. 函数内在嵌套函数
        2. 内部函数可以引用外层的参数和变量
        3. 参数和变量不会被垃圾回收机制回收
7. 继承
    1. 借用构造函数继承
    ```
    function Parent0 () {
      this.name = 'parent0',
      this.colors = ['red', 'green', 'blue']
    }
    Parent0.prototype.sex = '女'
    Parent0.prototype.say = () => {
      console.log('hello world')
    }
    function Child0 () {
      Parent0.call(this); // 或者apply
      this.type = 'child0';
    }
    new Child0().name; // parent0
    new Child0().colors; // ['red', 'green', 'blue']
    <!-- Parent0.call(this);在子类中执行父类的构造函数，通过这种调用，把父类构造函数的this指向为子类实例化对象引用，从而导致父类执行的时候父类里面的属性都会被挂载到子类的实例上去。 -->
    
    <!-- 通过这种方式的继承，父类原型上面的东西是没法继承，的无法函数复用，只能部分继承 -->
    ```
    2. 原型链继承
    ```
    function Parent1 () {
      this.name = "parent1";
      this.colors = ["red", "blue", "yellow"]
    }
    function Child1 () {
      this.name = "child1"
    }
    Child1.prototype = new Parent1();
    Parent1.prototype.sex = "女";
    Parent1.prototype.say = () => {
      console.log("hello world");
    }
    console.log(new Child1().sex); // 女
    new Child1().say(); // hello world
    <!-- 原型链继承确实实现了构造函数继承的缺点， -->
    let s1 = new Child1();
    s1.colors.push("black");
    let s2 = new Child1();
    console.log(s1.colors); // ["red", "blue", "yellow", "black"]
    console.log(s2.colors); // ["red", "blue", "yellow", "black"]
    // s1和s2一样的，是因为原型链上的原型对象是公用的
    ```
    3. 组合式继承
    ```
    // 3.组合式继承： 借用构造函数和原型链继承的优点，使得实例对象被隔离
    function Parent2 () {
      this.name = "parent2";
      this.colors = ['red', 'green', 'pink'];
    }
    function Child2 () {
      Parent2.call(this);
      this.type = "child2";
    }
    Child2.prototype = new Parent2();
    let o1 = new Child2();
    o1.colors.push("white");
    let o2 = new Child2();

    console.log(o1.colors); // ["red", "green", "pink", "white"]
    console.log(o2.colors); // ["red", "green", "pink"]
    // 父类构造函数被执行了两次，Child2.prototype = new Child2()
    ```
    4. 组合式继承优化1
    ```
    // 优化1--直接把父类的原型对象赋给子类的原型对象
    function Parent3 () {
      this.name = "parent3";
      this.colors = ['red','green','pink'];
    }
    Parent3.prototype.sex = "男";
    Parent3.prototype.say = function () {console.log('hello world')}

    function Child3 () {
      Parent3.call(this);
      this.type = "Child3";
    }
    Child3.prototype = Parent3.prototype;
    let h1 = new Child3();
    let h2 = new Child3();
    console.log(h1, h2);

    console.log(h1 instanceof Child3);
    console.log(h1 instanceof Parent3);
    // 我们无法区分实例对象s1到底是由Child3直接实例化的还是Parent3直接实例化的。用instanceof关键字来判断是否是某个对象的实例就基本无效了。
    console.log(h1.constructor.name); // Parent3
    // s1的构造函数居然是Parent3，显然不是我们想要的
    ```
    5. 组合式继承优化2
    ```

    // 优化2
    function Parent4 () {
      thsi.name = "parent4";
      this.colors = ['red', 'pink', 'green', 'white'];
    }
    Parent4.prototype.sex = "男"
    Parent4.prototype.say = () => {
      console.log("hello world");
    }
    let children4 = () => {
      Parent4.call(this);
      this.type = 'child4';
    }
    children4.prototype = Object.create(Parent4.prototype);
    children4.prototype.constructor = children4;
    // Object.create是一种创建对象的方式，它会创建一个中间对象
    let p = {name: 'P'}
    let obj = Object.create(p);
    Object.create({name: 'p'})
    // 通过这种方式创建对象，新创建的对象obj的原型就是p，同时obj也拥有了属性name，这个新创建的中间对象的原型对象就是它的参数。
    ```
    6. ES6中的继承
    ```
    // ES6
    class Parent {}
    class child extends Parent {
      constructor (x, y, colors) {
        super(x, y); // 调用父类的constructor(x, y)
      }
      toString() {
        return this.colors + ' ' + super.toString(); //调用父类的toString
      }
    }
    // 上面的代码中，constructor和toString方法中都出现了super关键字，在这里表示父类的构造函数，用来新建父类的this对象

    // 子类必须在constructor方法中调用super方法，否则新建实例时候会报错，如果子类没有定义constructor方法，这个方式会被默认添加。

    // ES5的继承，实质是先创造子类的实例对象this，然后将父类的方法添加到this上面(Parent.apply(this)).
    // ES6的继承，实质是先创造父类的实例对象this(所以必须先调用super方法)，然后在用子类的构造函数修改this
    ```
7. vue的api
    1. vue.js
      1. vue是JS MVVM库，vue只关心视图层。
      2. vue是以数据驱动的，vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，DOM会跟着变化。
      3. viewModel是Vue的核心，它是vue的实例。vue实例时作用域某个HTML元素上的，这个html元素可以是body，也可以是某个id所指代的元素。
      4. DOM Listeners 和 Data Bindings是实现双向绑定的关键，DOM Listener 监听页面所有的View层DOM元素的变化，当发生变化，Model层的数据随之变化；Data Binding监听Model层的数据，当数据发生变化，view层的DOM元素随之变化。
    2. vue.js特点
        1. 简洁: 页面由html模板+json数据+vue实例组成
        2. 数据驱动: 自动计算属性和追踪依赖的模板表达式
        3. 组件化: 可复用，解耦的组件来构造页面
        4. 轻量: 代码量小，不依赖其他库
        5. 快速: 精确有效批量DOM更新
        6. 模板友好: 可通过npm，bower等多种方式安装，很容易融入。
    3. 声明式渲染(View+Json数据(Model)+Vue实例(ViewModel))组成。创建一个vue实例，需传入一个选项对象，如: el,data,mounted,created,methods等
    4. 双向绑定 v-model
    5. vue.js指令: 
        1. v-if，通过表达式的值的真假来插入和删除元素，表达式返回一个布尔值。当v-if为true的时候，元素才会在代码中
        2. v-show，无论v-show的值是否为true或者false，元素都会存在html代码中。v-show的指令只是设置了css元素的style值。
        3. v-else, 必须紧紧跟着v-if或者v-show，否则无法工作。v-else绑定的元素能否渲染在html中，可取决于前面使用的v-if还是v-show.若前面使用的是v-if,且v-if值为true，则v-else不会渲染；若前面是v-show，且v-show的值为true的时候，v-else仍然会在html中。
        4. v-for循环
        5. v-bind绑定元素
        6. v-on监听DOM事件
        3. v-model数据双向绑定
    6. vue生命周期:
        1. 创建前、后
        2. 挂载前、后
        3. 更新前、后
        4. 销毁前、后

7. ajax和fetch的区别？
    1. ajax的本质是使用XMLHttpRequest对象来请求数据
    ```
    function ajax (url, fnSunc, fnFaild) {
        <!--1.创建ajax对象-->
        if (window.XMLHttpRequest) {
            var xhr = new XMLHttpRequest();
        } else {
            var xhr = new ActiveXObject("Microsoft.XMLHTTP");
        }
        
        <!--2.连接服务器-->
        xhr.open("GET", url, true);
        
        <!--3.发送-->
        xhr.send();
        
        <!--4.接收数据-->
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4) {
                if (xhr.status == 200) {
                    alert("成功" + xhr.responseText);
                    fnSunc(xhr.responseText);
                } else {
                    alert(失败了);
                    fnFaild();
                }
            }
        }
    }
    ```
    2. fetch是全部变量window的一个方法，他的主要特点是:
        1. 第一个参数是url
        2. 第二个可选参数，可以控制不同配置的init对象
        3. 使用了js Promises来处理结果/回调
        ```
        fetch("/some/url").then(function (responese) {
            return  // 执行成功，第一步
        }).then(function (returnedValue) {
            //  执行成功，第二部
        }).catch (function (err) {
            // 中途有任何错误，在此处理
        }) 
        ```
    3. fetch规范和jQuery.ajax()主要有两种方式不同
        1. 从fetch()返回的Promise将不会拒绝HTTP错误状态，即时响应是一个HTTP 404或500.相反，他会正常解决(其中ok状态设置为false)，并且仅仅在网络故障时或任何阻止请求完成时，他才会拒绝。
        ```
        <!--做简单的封装-->
        function checkStatus(response) {
            if (response.status >= 200 && response.status < 300) {
                return response
            } else {
                var error = new Error(response.statusText)
                error.response = response
                throw error
            }
        }
        
        function parseJSON (response) {
            return response.json()
        }
        
        fetch('/uses')
            .then(checkStatus)
            .then(parseJSON)
            .then(function (data) {
                console.log('request succeeded with JSON response', data)
            })
            .catch(function (error) {
                console.log('request failed', error)
            })
        ```
        2. 默认情况下，fetch在服务端不会发送或接收任何cookies，如果站点依赖于维护一个用户会话，则导致未经认证的请求(要发送cookies，必须发送凭据投)。这一点也可以做一些处理，如果想要在同域中自动发送cookie，加上credentials的same-origin选项
        ```
        fetch(url, {
            credentials: "same-origin"
        })
        ```
        3. same-origin值使得fetch处理Cookie与XMLHttpRequest类似。 否则，Cookie将不会被发送，导致这些请求不保留认证会话。
           对于CORS请求，使用include值允许将凭据发送到其他域：
         ```
         fetch(url, {
             credentials: "include"
         })
         ```
    4. fetch采用了Promise的异步处理机制，使用起来比ajax简单。
8. webpack配置
    1. webpack的原理，
        1. webpack是把项目当做一个整体，通过一个给定的主文件，webpack将从这个文件开始找到你的项目所依赖文件，使用loaders处理他们，最后打包成一个或者多个浏览器可识别的js文件
        2. install
            1. `npm install webpack webpack-dev-server --save-dev`，webpack是我们需要的模块打包机，webpack-dev-server用来创建本地服务器，监听我们的代码修改，并自动刷新我们修改后的结果。
            ```
            <!-- devServer的配置 -->
            cententBase, // 为文件提供本地服务器
            port, // 监听端口，默认8080
            inine， // 设置为true，源文件发生改变会自动刷新页面
            historyApiFallback, // 依赖H5的history API，设置为true，所有的页面跳转指向index。html
            devServer: {
              contentBase: './src', // 本地服务器所加载的页面所在的目录
              historyApiFallback: true, // 不跳转
              inline: true // 实时刷新
            }
            然后我们在根目录下面创建一个`webpack.config.js`,在`package.json`添加两个命令用于本地开发和生产发布
            "scripts": {
              "start": "webpack-dev-server",
              "build": "webpack"
            }
            <!-- 在使用webpack命令的时候，他将接受webpack的配置文件 -->
            ```
        3. entry
            1. entry:用来写入口文件，它将是整个依赖关系的根
            ```
            var baseConfig = {
              entry: './src/index.js'
            }
            ```
            2. 当我们需要多个入口文件的时候，可以将entry写成一个对象(建议用此方法)
            ```
            var baseConfig = {
              entry: {
                main: './src/index.js'
              }
            }
            ```
        4. output
            1. output: 即使入口文件有多个，但是只有一个输出配置
            ```
            var path = require('path')
            var baseConfig = {
              entry: {
                main: './src/index.js'
              },
              output: {
                filename: 'main.js',
                path: path.resolve('./build')
              }
            }
            module.exports = baseConfig;
            ```   
        5. Loader的作用:
            1. 实现对不同格式的文件的处理，比如说将scss转成css，或者typescript转为js
            2. 转换这些文件，从而使其能够被添加到依赖图中
            3. loader是webpack最重要的部分之一，通过使用不同的loader，我们能够调用外部的脚本或者工具，实现对不同格式文件的处理，loader需要在webpack.config.js里面单独用module进行配置。配置如下
            ```
            test: 匹配所处理文件的扩展名的正则表达式(必须)
              loader: loader的名称 (必须)
              include/exclude: 手动添加处理的文件，屏蔽不需要处理的文件(可选)
              query: 为loaders提供额外的设置选项
              ex: 
                  var baseConfig = {
                    // ...
                    module: {
                      rules: [
                        {
                          test: /* 匹配文件后缀名的正则 */,
                          use: [
                            loader: /* loader名字 */,
                            query: /* 额外配置 */
                          ]
                        }
                      ]
                    }
                  }
            <!-- 要是loader工作，我们需要一个正则表达式来标识我们修改的文件，然后有一个数组表示我们即将使用的loader，我们需要的loader需要通过npm进行安装。 -->
            ```
            4. 我们要解析less文件
            ```
            var baseConfig = {
              entry: {
                main: "./src/index.js"
              },
              output: {
                filename: '[name].js',
                path: path.resolve('./build')
              },
              devServer: {
                contentBase: './src',
                historyApiFallback: true,
                inline: true
              },
              module: {
                rules: [
                  {
                    test: /\.less$/,
                    use: [
                      {loader: 'style-loader'}
                      {loader: 'css-loader'}
                      {loader: 'less-loader'}
                    ],
                    exclude: /node_modules/
                  }
                ]
              }
            }
            ```
            5. 介绍几款loader
                1. babel-loader: 让下一代的js转换成现在浏览器能支持的js文件
                2. babel有些复杂，所有大部分会新建.babelrc文件进行配置
                3. css-loader，style-loader，两个配合使用，解析css文件，能够解析@import,url（）如果需要解析less就在后面加一个less-loader
                4. file-loader，生成的文件名就是文件内容的MD5哈希值并会保留所引用资源的原始扩展名
                5. url-loader，功能类似file-loader，但是文件大小地于指定的限制时，可以返回一个DataURL
                6. npm会提示的
        6. Plugins
            1. plugins和loader容易混淆，说的都是外部引用。事实上，完全不同。loaders负责的是处理源文件的，如css，jsx，一次处理一个文件。而plugins并不是直接操作单个文件，他直接对整个构建过程起到作用。下面举例我们常用的plugins:
            ```
            <!-- 1. ExtractTextWebpackPlugin, 他会将入口中引用css文件，都打包成独立的css文件中，而不是内签到js文件中 -->
            var ExtractTextWebpackPlugin = require('extract-text-webpack-plugin')
            var lessRules = {
              use: [
                {loader: 'css-loader'},
                {loader: 'less-loader'}
              ]
            }
            var baseConfig = {
              // ...
              module: {
                rules: [
                  // ...
                  {test: /\.less$/, use: ExtractTextWebpackPlugin(lessRules)}
                ]
              },
              plugins: [
                new ExtractTextWebpackPlugin('main.css')
              ]
            }

            <!-- 2. HtmlWebpackPlugin，依据一个简单的index.html模板，生成一个自动引用你打保后的js文件的新index.html -->
            var HtmlWebpackPlugin = require('html-webpack-plugin')
            var baseConfig = {
              // ...
              plugins: [
                new HtmlWebpackPlugin()
              ]
            }

            <!-- 3. HotModuleReplacementPlugin , 允许你在修改组件代码的时候，自动刷新实时预览修改后的结果。但是不要在生产环境中使用-->
            const webpack = require('webpack')
            const HtmlWebpackPlugin = require('html-webpack-plugin')
            const ExtractTextWebpackPlugin = require('extract-webpack-plugin')
            var lessRules = {
              use: [
                {loader: 'css-loader'},
                {loader: 'less-loader'}
              ]
            },
            module.exports = {
              entry: {
                main: './src/index.js'
              },
              output: {
                filename: '[name].js',
                path: path.resolve('./build')
              },
              devServer: {
                contentBase: './src',
                historyApiFallback: true,
                inline: true,
                hot: true
              },
              module: {
                rules: [
                  {test: /\.less$/, use: ExtractTextWebpackPlugin.extract(lessRules)}
                ]
              },
              plugins: [
                new ExtractTextWebpackPlugin('main.css')
              ]
            }
            ```
        7. 产品构建阶段
            1. 目前为止，开发阶段的东西基本完毕。但是在产品阶段，还需要对资源进行别的处理。(压缩，优化，分离js和css)
                1. 首先我们定义产品的环境
                ```
                var ENV = process.env.NODE_ENV
                var baseConfig = {
                  // ...
                  plugins: [
                    new webpack.DefinePlugin({
                     'process.env.NODE_ENV': JSON.stringify(ENV)
                    })
                  ]
                }
                ```
                2. 然后还需要修改我们的script命令
                ```
                'scripts': {
                  'start': 'NODE_ENV = development webpack-dev-sever',
                  'build': 'NODE_ENV = production webpack'
                }
                ```
                3. process.env.NODE_ENV将会被一个字符串代替，她运行压缩器排除那些不可到达的开发代码分支。当你引入那些不会进行生产的代码，下面的代码就很有用
                ```
                if (process.env.NODE_ENV === 'development') {
                  console.log('这个警告会在生产阶段消失')
                }
                ```
        8. 优化插件
            1. OccurenceOrderPlugin: 为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，然后为他们分配最小的id
            2. UglifyJsPlugin: 压缩代码
            ```
            var baseConfig = {
              // ...
              new webpack.optimize.OccurenceOrderPlugin(),
              new webpack.optimize.UglifyJsPlugin(),
            }
            ```
            3. 然后我们执行`npm run build`就可以进行压缩
    2. Loader的原理，
        1. webpack中的loaders是很重要的一部分。我们知道webpack是对资源进行打包的，里面的所有资源都是模块，内部实现了对模块资源进行加载的机制。但是webpack本身只能处理js模块，如果要处理其他类型的文件，就需要使用loader进行转换。loader可以理解为模块和资源的转换器，它本身是一个函数，接受原文件作为参数，返回转换的结果。Loader可以再require()引用模块的时候添加，也可以在webpack全局配置中进行绑定，还可以通过命令行的方式使用。
        2. 在配置module的loaders。loaders是一个数组，里面的每一个对象都用正则表达式，对应着一种配对方案。loader加载器用于将不同的文件加载到js文件中，比如url-loader用于在js中加载png/jpg格式的图片文件；css/style loader用于加载css文件；less-loader加载器是将less编译成css文件；不同的处理器通过!分隔并串联起来。这里的loader是可以省略掉-loader这样的，也就是原本应该写成style-loader!css-loader!sass-loader。
    3. 你有用那些优化措施
9. node接口
10. 优化

11. 链式调用的原理
    1. 通过在对象的最后加上return this 来实现的，当某个函数执行完毕，再把执行的对象返回，这样其他的函数就能继续调用了方法了，就形成链式操作。
    ```
    var obj = {};
    obj.a = function () {
      console.log('a')
      return this
    }
    obj.b = function () {
      console.log('b')
      return this
    }
    obj.a().b()

    <!-- 也可以在构造函数里面用 -->
    function Foo() {
      var obj = {}
      obj.a = function (index) {
        // ...
        return this
      }
    }
    <!-- 调用 -->
    var demo = Fun()
    $('#btn').click(function () {
      demo.a(2);
    })
    ```
12. koa框架
    1. koa是一种简单好用的web框架，它的特点是优雅，简洁，表达力强，自由度高。代码只有1k多行，所有功能都通过插件实现。
    2. 安装：要检查node版本，至少9以上。下载koa
    3. 基本用法
        1. 架设HTTP服务
        ```
        const koa = require('koa');
        const app = new koa();
        app.listen(3000);
        <!-- 运行脚本node 1.js即可 -->
        ```
        2. Context对象，koa提供一个context对象，表示一次对话的上下文(包括HTTP请求和HTTP回复)。通过加工对象，就可以控制返回给用户的内容。`Context.response.body`属性就是发送给用户的内容。
        ```
        const koa = require('koa');
        const app = new koa();

        const main = ctx => {
          ctx.response.body = "hello world";
        }

        app.use(main);
        app.listen(3000);
        <!-- 其中main函数用来设置ctx.response.body.然后app.use方法加载main函数。ctx.response代表HTTP Response， ctx.request代表HTTP request -->
        ```
        3. HTTP Response的类型
          1. koa默认的返回类型是text/plain，如果想反悔其他类型，可以用ctx.request.accepts判断一下，然后使用ctx.response.type指定返回类型。
          ```
          const main = ctx => {
            if (ctx.request.accepts('xml')) {
              ctx.response.type = 'xml';
              ctx.response.body = '<data>hello world</data>'
            } else if (ctx.request.accepts('html')) {
              ctx.response.type = 'html';
              ctx.response.body = '<p>hello world</p>'
            } else if (ctx.request.accepts('json')) {
              ctx.response.type = 'html';
              ctx.response.body = {data: hello world}
            } else {
              ctx.response.type = 'text';
              ctx.response.body = 'hello world';
            }
          }
          ```
        4. 网页模板，实际开发中，返回给用户的网页往往都是携程模板文件。我们可以让koa限度去模板文件，然后将这个模板返回给用户。
        ```
        const fs = require('fs');
        const main = ctx = > {
          ctx.response.type = 'html',
          ctx.response.body = fx.createReadStream('./demos/template.html');
        }
        ```
    4. 路由
        1. 原生路由，通过`ctx.request.path`，可以获取用户的请求路径，实现简单的路由。
        2. koa-route模块， 原生路由比较麻烦，我们用封装好的koa-route模块。
        3. 静态资源，koa-static模块封装了这部分请求。
        4. 重定向，有些情况服务器需要重定向访问请求，ctx.response.redirect()方法发出重定向，将用户指向另外一个路由。
    5. 中间件
        1. Logger(打印日志)
        2. 中间件概念
        ```
        const logger = (ctx, next) => {
          console.log(`${Date.now() ${ctx.request.method} ${ctx.request.url}}`)
          next()
        }
        app.use(logger);
        <!-- koa所有的功能都是通过中间件实现的，前面的demo中的main也是中间件。每个中间件默认接受两个参数，第一个参数是Context，第二个参数是next函数。只要调用next函数，就可以把执行权交给下一个中间件 -->
        ```
        3. 中间件栈，多个中间件会形成中间件栈(middle stack),以先进后出的顺序执行。如果没有调用next()，则执行权不会传递下去。
        4. 异步中间件，必须写成async函数
        ```
        const fs = require('fs');
        const Koa = require('koa');
        const app = new Koa();

        const main = async function (ctx next) {
          ctx.response.type = 'html';
          ctx.response.body = await fs.readFile('./demos/template.html)
        }
        app.use(main);
        app.listen(3000);
        <!-- fs.readFile是一个异步操作，必须写成 await fs.readFile(),中间件必须写成async函数 -->
        ```
        5. 中间件的合成，koa-compose将多个中间件合为一个。
    6. 错误处理
        1. 500错误，ctx.throw()方法抛出500错误
        2. 404错误，ctx.response.status = 404,然后ctx.throw()抛出错误
        3. 处理错误的中间件，try...catch...将其捕获
        4. error事件的监听
        5. 释放error事件
    7. Web App功能
        1. cookies
        2. 表单
        3. 文件上传
13. 版本管理
    1. git
        1. git status
        2. git add *
        3. git commit -m '...'
        4. git pull origin master
        5. git push origin master
        6. git reset -hard 放弃本地修改
        7. 分支
            1. git checkout -b 分支名    新建分支
            2. git checkout 分支名  切换分支
            3. git branch 查看本地分支
            4. git branch -a 查看所有分支
            5. 删除本地分支 git branch -d 分支名 (此命令不能删除当前分支，要先切换到其他分支)
            6. git checkout master, git pull origin master, git merge 分支名，git push origin master
            7. 查看远程分支 git branch -r
            8. 新建与远程分支相对应的本地分支 git checkout -b v2.9 origin/v2.9 
    2. svn
14. 对数组的操作
    1. ES5
        1. join(separator); 将数组的元素组成字符串，以separator为分隔符，默认是逗号，该方法只接受一个参数，即分隔符。
        2. push():可以接受任意数量的参数，把他们逐个添加到数组的末尾，并返回修改后数组的长度，和pop():数组末尾移除最后一项，减少数组的length值，然后返回移除的项。
        3. shift(): 删除原数组第一项，并返回删除元素的，值，如果数组为空，就返回undefined，和unshift(): 将参数添加到数组的开头，返回数组的长度
        4. sort():按照升序排列数组项。sort()会调用每个数组项的toString()方法，转成字符串在进行对比
        5. reverse()反转数组项的书序
        6. concat() 将参数添加到原数组中，返回一个新数组
        7. slice(),返回从原数组中指定开始下标和结束下标之间的选项组成的新数组。可以接受一个参数或者2个参数，如果是一个参数，表示从当前下标开始到结束项。如果是两个参数，表示起始的坐标，不包含右边的参数。
        8. splice(),
            1. 删除，可以删除任意数量的选项，两个参数，要删除的第一项的位置和要删除的项。
            2. 插入，可以再指定位置插入任意数量的项，要三个参数(起始位置、要删除的项数、要插入的项)
            3. 替换，可以再指定位置插入任意数量的项，且同时删除任意数量的项。三个参数: 起始位置、要删除的项数，要插入的任意数量的项。
        9. indexOf(),2个参数:要查找的项和(可选的)表示查找起点位置的索引，从数组的开始位置查找， lastIndexOf(),2个参数:要查找的项和(可选的)表示查找起点位置的索引，从数组的结束位置查找
        10. forEach:  `arr.forEach( (item, index, a) => {})`对数组进行循环
        11. map(): 映射。对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组 。`arr.map((item) => {return irem*2;})`
        12. filter():过滤
        13. every(): 判断数组中的每一项是否满足条件，所有的满足条件返回true
        14. some(): 判断数组中的每一项是否满足条件，其中一项满足就返回true
    2. ES6
        1. Array.form()，将两类对象转为真正的数组:类似数组的对象和可遍历的对象。
        2. Array.of(), 将一组值转为数组。
        3. copyWithin(), 在当前数组内部，从指定位置的成员复制到它的位置，返回当前数组。
        4. find()和findIndex()，找到第一个符合条件的数组成员和成员的位置
        5. fill(): 使用给定的值，填充一个数组
        6. entries(),keys(),values()。用于遍历数组，可以用for…of循环进行遍历。keys()对健名的遍历，values是对键值的遍历、entries()是对键值对的遍历。 
        7. includes()，表示数组是否包含给定的值。
15. ul和ol的区别
    1. ul: 无序列表，
    2. ol: 有序列表，
    3. 两者前面的符号都可以修改，通过改type值。
        1. ul的type值: disc-实心圆，circle-空心圆，squar-e实心方块
        2. ol的type值：1-数字，a-小写字母，A-大写字母
16. call和apply的区别
    1. js中的每一个Function对象都有一个apply()方法和call()方法，它们的语法分别为`function .apply(thisObj[, argArray])和function.call(thisObj[, arg1[,arg2[, ...argN]])`
    2. apply，调用一个对象的一个方法，用另一个对象替换当前对象。B.apply(A, arguments),即A对象应用B对象的方法。
    3. apply，调用一个对象的一个方法，用另一个对象替换当前对象。B.call(A, args1, args2, args3),即A对象调用B对象的方法
    4. 共同之处: 都可以用来代替另一个对象调用方法，将一个函数的对象上下文从初始的上下文改变为由thisObj指定的对象。
    5. 不同：
        1. apply，最多只能有两个参数---新的this对象和一个数组argArray。如果给该方法传递多个参数，则需要将参数写进该数组里面，即使只有一个参数，也要写进数组。
        2. call，可以接受多个参数，第一个参数和apply一样，后面则是一串参数列表。
17. JS由以下三个部分组成:
    1. ECMAScript（核心）:JavaScript语言基础
    2. DOM(文档对象模型)：规定了访问html和xml的接口
    3. BOM(浏览器对象模型)：提过了浏览器窗口之间进行交互的对象和方法
18. JS的数据类型
    1. 基本数据类型: String、Number、Boolean、Undefined、Null、symbol
    2. 引用数据类型: Function、Object、Array、Date、RegExp
19. 检测浏览器版本有哪些方式
    1. 根据navigator.userAgent // "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1"
    2. 根据window的对象成员
20. JS有哪些内置对象？
    1. 数据封装类对象：Object/Array/Boolean/Number/String
    2. 其他对象：Function/Arguments/Math/Date/RegExp/Error
    3. ES6新增对象: Symbol/Map/Set/Promises/Proxy/Reflect
21. 谈谈JS的基本规范？
    1. 代码缩进，建议使用"四个空格"缩进；
    2. 代码段使用{}包裹；
    3. 语句结束使用;
    4. 变量和函数在使用前进行声明
    5. 以大写字母开头命名构造函数，全大写命名常量
    6. 规范定义JSON对象，补全双引号
    7. 用{}和[]声明对象和数组
22. 如何编写高性能的javascript？
    1. 遵循严格模式‘use strict’
    2. 将js脚本放在页面底部，加快渲染页面
    3. 将js脚本成组打包，减少请求
    4. 使用非阻塞方式下载js脚本
    5. 尽量使用局部变量来保存全局变量
    6. 尽量减少使用闭包
    7. 使用window对象属性方法时，省略window
    8. 尽量减少对象成员嵌套
    9. 缓存DOM节点的访问
    10. 通过避免使用eval()和Function()构造器
    11. 给setTimeout()和setInterval()传递函数而不是字符串作为参数
    12. 尽量使用直接量创建对象和数组
    13. 最小化重绘(repaint)和回流(reflow)
23. 根据浏览器的渲染过程，DOM树和渲染树的区别？
    1. 浏览器的渲染过程:
        1. 解析HTML构建DOM，并行请求css/image/js
        2. css文件下载完成，开始构建CSSOM(CSS树)
        3. CSSOM构建结束后，和DOM一起生产Render Tree(渲染树)
        4. 布局(Layout)： 计算每个节点在屏幕的位置
        5. 显示(Painting): 通过显卡把页面画到屏幕上
    2. DOM树和渲染树的区别：
        1. DOM树和HTML标签一一对应，包括head和隐藏元素
        2. 渲染树不包含head和隐藏元素，大段文本中的每一行都是一个独立节点，每一个节点都有对应的css属性
24. 重绘和回流的区别和联系？
    1. 重绘: 当渲染树中的元素外观(如：颜色)发生改变，不影响布局时，产生重绘
    2. 回流: 当渲染树中的元素的布局(如：尺寸、位置、隐藏、状态)发生改变的时候，产生重绘回流
    3. 注意: js获取Layout属性值(如：offsetLeft、scrollTop、getComputedStyle等)也会引起回流。因为浏览器需要通过回流重新计算值
    4. 回流必将引起重绘，而重绘不一定会引起回流。
25. 如何最小化重绘和回流？
    1. 需要对元素进行复杂的操作时，可以先隐藏(display: none;),操作完成后在显示
    2. 需要创建多个DOM节点时，使用DocumentFragment创建后一次性的加入document
    3. 缓存Layout的属性值。如：var left = elem.offsetLeft，这样，多次使用left只产生一次回流
    4. 尽量避免用table布局
    5. 避免使用css表达式，因为每次调用都会重新计算值
    6. 批量修改元素样式
26. script是否会影响首屏显示的时间？
    1. 在解析HTML生产DOM过程中，js文件的下载是并行的，不需要DOM处理到script节点。因此script的位置不会影响首屏的开始时间
    2. 浏览器解析HTML是自上而下的线性过程，script作为HTML的一部分同样遵循这个原则
    3. 因此，script会延迟DomContentLoad，只显示上部分首屏内容，从而影响首屏显示的完成时间
27. js中的作用域和变量声名提升？
    1. js作用域：
        1. 在java、c语言中，作用域为for语句，if语句或者{}内的一块区域，称为作用域
        2. 在js中，作用域为function(){}内的区域，称为函数作用域
    2. js变量声明提升：
        1. 在js中，函数声明和变量声明经常被js引擎隐式的提升到当前作用域的顶部
        2. 声明语句中的赋值部分并不会被提升，只有名称被提升；
        3. 函数声明的优先级高于变量，如果变量名和函数名相同，且没有赋值，则函数声明会覆盖变量声明
        4. 如果函数有多个同名参数，那么最后一个参数会覆盖前面的同名参数。
28. javascript有几种类型的值？能画出啦内存图？
    1. 原始数据类型： Undefined、Null、String、Boolean、Number --- 栈
    2. 引用数据类型： 对象，数组，函数 --- 堆
    3. 两种类型的区别: 存储位置不同
    4. 原始数据类型是直接存放在栈中的简单数据段，占据空间小，大小固定，属于被频繁使用的数据；
    5. 引用数据类型存放在堆中的对象，占用空间大，大小不固定，如果存储在栈中，将会影响程序运行的性能
    6. 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址
    7. 当解析器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。
29. js如何实现一个类，怎么实例化这个类？
    1. 构造函数法(this+prototype) --- 用new关键字生成实例对象
        1. 缺点: 用到了this和prototype，编写复杂，可读性比较差
        ```
        function Mobile(name, price) {
            this.name = name;
            this.price = price;
        }
        Mobile.prototype.sell = function () {
            alert(this.name + ",售价$" + this.price)
        }
        var iphone7P = new Mobile("iphone7p", 6488);
        iphone7p.sell();
        ```
    2. Object.create法 --- 用Object.create()生成实例对象
        1. 缺点: 不能实现私有属性和私有方法，实例对象之间也不能共享数据
        ```
        var Person = {
            firstName: "Hong",
            lastNmae: "JingPing",
            age: 22,
            introduce: function () {
                alert(‘I am’ + Person.firstName + " " + Person.lastNmae)
            }
        }
        var person = Object.create(Person);
        person.introduce();
        
        <!--Object.create要求IE9+ 低版本浏览器可自动进行部署-->
        if (!Object.create) {
            Object.create = function (o) {
                function F() {}
                F.prototype = o;
                return new F();
            }
        }
        ```
    3. 极简主义法(消除this和prototype) --- 调用createNew()得到实例对象
        1. 优点：容易理解，结构清晰优雅，符合传统的"面向对象编程"的构造
        ```
        var Cat = {
            age: 6, // 共享数据 --- 定义在类对像内，createNew外
            createNew: function () {
                var cat = {};
                // var cat = Animal.createNew(); // 继承Animal类
                cat.name = "amy";
                var sound = "mie mie mie"; // 私有属性---定义在 createNew()内，输出对象外
                cat.makeSound = function () {
                    alert(sound); // 暴露私有属性
                };
                cat.changeAge = function (num) {
                    Cat.age = num; // 修改共享数据
                };
                return cat; // 输出对象
            }
        };
        
        var cat = Cat.createNew();
        cat.makeSound();
        ```
    4. ES6语法糖Class --- 用new关键字生成实例对象
    ```
    class Point() {
        constructor (x,y) {
            this.x = x;
            this.y = y;
        }
        toString() {
            return '(' + thsi.x + ',' + thsi.y + ')';
        }
    }
    var point = new Point(2, 3);
    ```