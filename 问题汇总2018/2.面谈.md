1. Q: 问的时候你用过静态方法,静态属性,私有变量么?
    1. 静态方法是ES6之后才有的
        1. 方法不能给this引用，可以给类直接引用
        2. 静态不可以给实例调用，比如`let a = new ParentClass => a.sayHello()`会抛出异常
        3. 父类静态方法，子类非static方法没法覆盖父类
        4. 静态方法可以给子类继承
        5. 静态属性可以继承也可以被修改
    2. 私有变量没有private这个关键字，基本用下划线认为区分。
    3. 私有变量的模拟方案WeakMap可以避免内存泄露,当没有被值引用的时候会自动给内存寄存器回收了.
    ```
    const _ = new WeakMap(); // 实例化，value必须为对象，有delete，get，has，set四个方法
    class TestWeakMap {
      constructor (id, barcode) {
        _.set(this, {id, barcode});
      }
      testFunc () {
        let {id, barcode} = _.get(this); // 获取对应的值
        return {id, barcode};
      }
    }
    ```
2. Q: 谈谈你对 Promise 的理解? 和 ajax 有关系么?
    1. Promise和ajax没有直接关系，promise只是为了解决"回调地狱"而诞生的；
    2. 平时结合ajax是为了更好梳理和控制流程。
    3. Promise有三种状态，Pending/resolve()/reject()
    4. 需要注意的地方:
        1. 在Pending转为另外两种之一的状态时候，状态不可在改变
        2. promise的`then`为异步，而`new Promise()`构造函数内为同步
        3. promise的`catch`不能捕获任何情况下的错误(比如`then`里面的`setTimeOut()`内手动抛出一个`Error`)
        4. Promise的`resolve`若是传入值，而非函数，会发生值穿透的现象
        5. Promise的`catch`还是`then`，`return`的都是一个新的`promise`(在`promise`没有被终端的情况下)
        6. Promise有一些自带的方法，比如race，all。race有任一一个解析完毕就会返回，all是等到所有的解析完毕再返回。
        7. 实现一个延时的 promise 函数, 可以用async和await？
        ```
        const delay = (time) => new Promise((resolve, reject) => {
          setTimeout(resolve, time);
        })

        <!-- test -->
        let testRun = async function () {
          console.log(1);
          await delay(2000);
          console.log('我两秒后才触发', 3);
        }
        ```
3. Q: 谈谈你对 TCP 的理解？
    1. Q: TCP 是在哪个OSI 的哪个层!通讯过程是全双工还是半双工(单工)?
        1. TCP是在传输层，全双工
    2. Q: TCP的通讯的过程是怎么样的!
        1. 整个过程是三次握手，四次挥手
    3. Q: 你说的没错,说说整个过程如何?
        1. 三次握手就是：A1(吼叫方,客户端)想要呼叫 A2(控制室的某某,服务端)，
            1. A1对着对讲机说"over over ,听到请回答"(第一次,请求应答) ...
            2. A2收到回应"收到收到,你说"(第二次,确认应答)
            3. A1开始巴拉巴拉个不停而 A2没拒绝(第三次,通讯建立)
        2. 四次挥手就是两者确认互相倾述完毕的过程..
            1. A1说:"控制室,报告完毕了"(第一次挥手)
            2. A2说:"知道了...那么你废话说完就好好听我指挥....巴拉巴拉.."(第二次挥手)
            3. A1此时等待控制室说完毕,而控制室等回应(第三次挥手)
            4. 等到 A1回馈控制室确认都知道完毕了..(第四次挥手)...
        3. TCP没有百分百建立成功的,会造成链接失败的情况有很多..
4. Q: TCP 你了解了,那么 OSI 七层协议和五层网络架构应该知道吧?
    1. OSI七层涵盖: 物理层，数据链路层，网络层，传输层，会话层，表示层，应用层；五层表示"会话、应用、表示"为同一层；
    2. Q: DNS 的大体的执行流程了解么,属于哪个层级?工作在哪个层级?
        1. DNS属于应用层协议，至于TCP/UDP哪一层上面跑，看情况，大体的执行顺序
            1. 优先读取浏览器缓存
            2. 其次是系统的缓存
            3. 都没有的情况下，找本地host文件(比如你写的映射关系优先查找)
            4. 再没有的情况下，找最近的域名解析器
            5. 在没有的话，扩大访问，最终找到根服务器，没有的话就是失败
    3. DNS 的解析的几个记录类型需要了解:
        1. A: 域名直接到IP
        2. CNAME: 可以多个域名映射到一台主机，类似在github page 就用cname指向
        3. MX: 邮件交换记录，用的不多，一般搭建邮件服务器才会用到
        4. NS: 解析服务记录，可以设置权重，指定谁解析
        5. TTL: 就是生存时间(缓存时间)，一般的域名解析商都有默认值，也可以人为设置
        6. TXT: 一般指某个主机名或域名的说明
5. Q: HTTP 和 HTTPS 有何差异? 听说过 SPDY 么?
    1. HTTP相对于HTTPS来说，速度较快且开销较小(没有SSL/TSL)对接，默认是80窗口;
    2. HTTP容易遭受域名劫持，而HTTPS相对来说较为安全但开销交大(数据以加密的形式传递)，默认端口为443
    3. HTTP是明文跑在TCP上，而HTTPS跑在SSL/TLS应用层之下，TCP上
    4. Q: 那么 HTTPS中的TLS/SSL是如何保护数据的...
        1. 一般是两种形式，非对称加密，生成公钥和私钥。私钥丢服务器，公钥每次请求去比对验证
        2. 更严谨的是采用CA，给密钥签名...
    5. Q: 你说到对称加密和非对称加密,能说说整个流程如何运转的么(HTTPS)
        1. 对称加密
            1. 双方都有同样的密钥，每次通讯都要生成一个唯一密钥，速度很快
            2. 安全性较低，且密钥增长的数量极快
        2. 非对称加密(RSA)
            1. 安全性很高，对资源消耗很大(CPU),目前主流的加密算法（基本用于交换密钥或者签名，而非所有通讯内容）
        3. CA(数字签名)
            1. 这个是为了防止中间人给偷换了造成数据被窃取而诞生的
            2. 用一些权威机构颁布的算法来签名，权威机构做中间人，通讯过程都会和机构核对一遍
    6. Q: SPDY 听说过么.什么来的?
        1. 谷歌推行一种协议(HTTP之下SSL之上[TCP])，可以算是HTTP2的前身
            1. 压缩数据(HEADER)
            2. 多路复用
            3. 优先级(可以给请求设置优先级)
    7. Q: 你对 HTTP 的状态吗了解多少...
        1. 1xx: 一般用来判断协议更换或者确认服务端收到请求这些
            1. 100:服务端收到部分请求，若是没有拒绝的情况下可以继续传递后续内容
            2. 101:客户端请求变换协议，服务端收到确认
        2. 2xx: 请求成功，是否创建链接，请求是否接受，是否有内容这些
            1. 200:(成功)服务器已成功处理了请求
            2. 201:(已创建)请求成功并且服务器创建了新的资源
            3. 202:(已接受)服务器已接受请求，但尚未处理
            4. 204:(无内容)服务器成功处理了请求，但是没有返回任何内容。
        3. 3xx: 一般用来判断重定向和缓存
            1. 301: 所有请求已经转移到新的url(永久重定向)，会被缓存
            2. 302: 临时重定向，不会被缓存
            3. 304: 本地资源暂未改动，优先使用本地的(根据IF-Modified-Since or IF-Match去比对服务器资源，缓存)
        4. 4xx: 一般用来确认授权信息，请求是否出错，页面是否丢失
            1. 400:请求出错
            2. 401:未授权，不能读取某些资源
            3. 403:阻止访问，一般也是权限问题
            4. 404:页面丢失，资源找不到
            5. 408:请求超时
            6. 415:没接类型不被支持，服务器不会接受请求
        5. 5xx: 基本都是服务端的错误
            1. 500:服务端错误
            2. 502:网关错误
            3. 504:网关超时
    8. Q: HTTP的请求报文是怎么样的,能大体的说下么?
        1. HTTP的请求报文 = 请求行 + 请求头 + 请求体;
            1. 请求行：访问的方法 + 协议 + 访问的URL构成
            2. 请求头: 如accept，content-type，user-agent这类键值对，服务端可以直接读取
            3. 请求体：如POST提交一个表单，我们编码后放在上面需要传递的
    9. Q: 请求报文知道,那你说说cookie是如何跟随请求的?
        1. Cookie就是保存在HTTP协议的请求或者应答头部（Cookie是由服务端生成）。
6. Q: 浏览器缓存和服务端的缓存控制你了解多少,说说看?
    1. Last-Modified:
        1. 第一次请求资源从服务器拉取的会自动带上该属性
        2. 第二次请求会跟服务端比对(IF-Modified-Since)时间，没有变动则使用本地的(304)
        3. 结合Expires(过期时间: 缓存的截止时间)，跟随请求一起发出，资源么有过期就拿本地，过期就重新发送请求
    2. Cache-control
        1. 是HTTP1.1的东西，判断资源是否过期结合max-age来替代Expires[http1.0]
    3. Etag:
        1. 第一次请求url时候会给服务器上标记(一串字符串)
        2. 第二次请求是会比对服务端的If-none-Match，没有改动依旧拿缓存  
7. Q: 几个短而让我印象深刻的题
    1. 几个短而让我印象深刻的题.html
8. Q:有字符串 var test='abc345efgabcab'; 请根据提示实现对应要求
    1. 字符串操作.html
10. Q: 你对基础算法这块掌握的如何....
    1. 你对基础算法这块掌握的如何.html
11. Q: 写一个二分法查找
    1. 写一个二分法查找.html
12. Q: 你对优化这块了解多少?
    1. 从客户端入手:
        1. 压缩代码(css/js),压缩图片；
        2. 合并一些小图片(css sprite);
        3. 若是打包的代码尽可能的切割成多个chunk，减少单一chunk过大
        4. 静态文件采用cdn引入
        5. http的缓存头使用的话合理
        6. 减少第三方库的依赖
        7. 对于代码应该考虑性能来编写，尽量减少页面重绘
        8. 渐进升级，引入preload这些预加载资源
        9. 看情况用server worker来缓存资源
    2. 从服务端入手:
        1. 带宽、域名解析、多域名解析等
        2. 页面做服务端渲染，减少对浏览器的依赖(不用客户端解析)
        3. 渐进升级，比如引入http2(多路复用，头部压缩这些可以明显加快加载速度)
13. Q: MySQL有哪些索引类型? 索引的数据结构储存方式? MySQL和 MongoDB的差异
    1. MySQL的索引类型:
        1. 普通索引: 就普通的类型
        2. 唯一索引: 代表索引的值唯一不重复(允许有空值),相对于上面多了个UNIQUE
        3. 主键索引：(创建表的跟随创建,唯一索引，不允许有空值)
        4. 组合索引: (就是将多个字段都建立到一个索引)
    2. 索引有利有弊,用的好加快查询速度,滥用索引会造成大量磁盘空间占用,维护性也会增多; 索引不会包含null的列
    3. 索引的数据结构储存方式,我只简单了解过B-Tree
    4. 至于MySQL 和 MongoDB的差异:
        1. 前者是关系型数据库, 后者非关系型数据库(数据是以文档的方式储存,值为 key-value);
        2. MySQL应用层面很广,有事务系统这些,链表查询这些都很方便.经常作为很多系统的主力数据库
        3. 而MongoDB作为NoSQL,虽然有些层面不如 MySQL,但是应用层面也挺广, 比如结合前端做一些用户的概要信息的维护,一些缓存信息的维护.
14. Q: 让你来为公司的一个项目做技术选型,你会怎么做,为什么?
15. Q: MVVM 和 MVC 的差异? 听说过 MVP?
16. Q: React,Angular,Vue的比较?
17. Q: 说说你对 VNode的理解,diff的过程;
18. Q: Vue-Router的两种模式主要依赖什么实现的
19. Q: 小程序以及React Native的差异..等等
